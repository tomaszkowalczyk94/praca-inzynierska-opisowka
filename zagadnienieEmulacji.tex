\chapter{Zagadnienie emulacji}
	
	Emulator w kontekście informatyki, oznacza program który jest przystosowany do uruchomienia na specyficznym urządzeniu lub/i systemie, i pozwala na uruchomienie programów napisanych z przeznaczeniem dla innego urządzenia/systemu\cite{howDoIWriteAnEmulator}. 
	
	Inną ciekawą definicję emulatora podał Victor Moya del Barrio "Emulacja w informatyce oznacza emulowanie zachowania urządzenia lub oprogramowania za pomocą innego oprogramowania lub urządzenia"
	\cite{studyofthetechniquesforemulationprogramming}.
		
	Emulacje CPU można przeprowadzić na 3 sposoby:\cite{fms_komkon_org_howto}	
	\begin{itemize}  
		\item emulacja przez interpretowanie
		\item emulacja przez statyczną re-kompilacje
		\item emulacja przez dynamiczną re-kompilacje
	\end{itemize} 
	Każda z tych metod wymaga oddzielnego omówienia.
	
	\section{Emulacja przez interpretowanie}
	Interpreter to najprostszy rodzaj emulatora. Odczytuje w pętli kod programu z wirtualnej pamięci. Odczytany bajt (lub bajty, rozkaz procesora może być wielobajtowy) zawiera informacje o rodzaju operacji jaką CPU powinno wykonać. Interpreter ma za zadanie odkodować informacje o operacji, a następnie ją wykonać. Między kolejnymi rozkazami powinien on zmienić wirtualne parametry (np inkrementacja licznika rozkazów), sprawdzić czy nie zostało wywołane przerwanie, obsłużyć urządzenia wejścia/wyjścia, liczniki, kartę graficzną, lub wykonać inne operacje zależne od emulowanego urządzenia. Przykładowa struktura interpretera została przedstawiona w kodzie \ref{listing:interpreter}.
	
	\begin{listing}[h]
		\inputminted{java}{listings/interpreter.c}
		\caption{Przykładowa struktura interpretera procesora}
		\label{listing:interpreter}
	\end{listing}
		
	Emulacja przez interpretowanie jest najwolniejszą formą emulacji, ale także najłatwiejszą w debugowaniu. Pozwala na prześledzenie wykonania operacji, i podgląd wewnętrznych stanów urządzenia. Z tego powodu jest najczęściej wybierana w debuggerach procesorów, mikro-kontrolerów dla programistów.
	
	\section{Statyczna re-kompilacja}
	Statyczna re-kompilacja (ang. "Static binary translation") to proces konwertowania kodu maszynowego na inny kod maszynowy przeznaczony dla docelowej architektury. Plik wykonywalny tłumaczony jest raz, za jednym podejściem przez cały plik. Problemem tego rozwiązania są instrukcje skoków pośrednich czyli takich gdzie adres skoku przechowywany jest w rejestrze lub pamięci, i może on być uzyskany tylko podczas wykonywania programu. W takim przypadku niemożliwym jest przetłumaczenie wszystkich instrukcji pliku wykonywalnego\cite{uqbt}. 
	
	
	\section{Dynamiczna re-kompilacja}
	Dynamiczna re-kompilacja (ang. "Dynamic binary translator"), w odróżnieniu od translacji dynamicznej, tłumaczy kod blokami, podczas jego wykonywania. Re-kompilacja występuje "na żądanie" co jest wolniejsze od statycznej re-kompilacji, ale rozwiązuje problem związany z statycznym tłumaczeniem kodu wykonywanego za instrukcjami skoków pośrednich.
	
	Raz przetłumaczony fragment kodu jest przechowywany w pamięci, na wypadek jego ponownego użycia, co pozwala zoptymalizować ten sposób emulacji\cite{uqbt}.
	
	
	Dynamicznej rekompilacji używa w dużym stopniu maszyna wirtualna javy. Wczesne wersje JVM (Java Virtual Machin) używały do swojego działania interpreterów, co okazało się mało wydajne. Dobrym sposobem na optymalizację maszyny wirtualnej okazało się dynamiczne tłumaczenie kodu maszynowego\cite{dynamicRecompilationInJava}. 
	
	
	
	\section{Różnica między symulacją a emulacją} 
	Różnicę w emulacji a symulacji obrazuje tabela \ref{table:emulationAndSimulation}.
	
	\begin{table}
		\centering
		\begin{tabular}{ m{7cm} | m{7cm} }
			Symulator &  Emulator  \\ 
			\hline
			System zdolny do naśladowania innego systemu w pewnym stopniu  & System który naśladuje dokładne zachowanie innego systemu \\   
			\hline
			Może nie przestrzegać wszystkich reguł symulowanego systemu & Ściśle przestrzega parametrów i reguł emulowanego systemu \\ 
			\hline
			Modeluje aplikacje i zdarzenia & Kopiuje zachowanie systemów \\ 
		\end{tabular}
		\caption{Tabela prezentująca różnice między symulacją a emulacją \cite{emulationOrSimulation}}
		\label{table:emulationAndSimulation}
	\end{table}
	
	W kontekście informatyki, symulator to program komputerowy, który modeluje zachowania i funkcje innego realnego systemu lub zjawiska (np. prowadzenie pojazdu). Nie jest wymagane, aby potrafił odwzorować jego wszystkie zachowania i funkcje. Symulator nie będzie w stanie wykonywać realnych zadań emulowanego urządzenia i nie będzie w stanie go zastąpić.
	
	Natomiast emulator ma za zadanie "udawać" dane urządzenie/zjawisko w takim stopniu, i na takim poziomie, aby był w stanie zastąpić emulowane urządzenie i funkcjonować tak jak one.
	
	% linki z których czerpałem wiedze:
	% https://www.guru99.com/real-device-vs-emulator-testing-ultimate-showdown.html
	% http://fms.komkon.org/EMUL8/HOWTO.html https://stackoverflow.com/questions/1584617/simulator-or-emulator-what-is-the-difference
	% https://www.quora.com/What-are-the-differences-between-simulation-and-emulation
	% TO NAJLEPSZE: https://softwareengineering.stackexchange.com/questions/134746/whats-the-difference-between-simulation-and-emulation
		
	% W książe "Study of the techniques for emulation programming" Victor Moya del Barrio podaje taką to definicje emulatora "An emulator tries to duplicate the behaviour of a full computer using software programs in a different computer."\cite{studyofthetechniquesforemulationprogramming}. 