\contentsline {chapter}{\numberline {1}Wst\IeC {\k e}p}{3}
\contentsline {chapter}{\numberline {2}Zagadnienie emulacji}{6}
\contentsline {section}{\numberline {2.1}Emulacja przez interpretowanie}{6}
\contentsline {section}{\numberline {2.2}Statyczna re-kompilacja}{7}
\contentsline {section}{\numberline {2.3}Dynamiczna re-kompilacja}{8}
\contentsline {section}{\numberline {2.4}R\IeC {\'o}\IeC {\.z}nica mi\IeC {\k e}dzy symulacj\IeC {\k a} a emulacj\IeC {\k a} (i mo\IeC {\.z}e virtualizacj\IeC {\k a}???)}{8}
\contentsline {chapter}{\numberline {3}Przegl\IeC {\k a}d istniej\IeC {\k a}cych rozwi\IeC {\k a}za\IeC {\'n}}{9}
\contentsline {section}{\numberline {3.1}Z80 SIMULATOR IDE}{9}
\contentsline {section}{\numberline {3.2}ZEMU - Z80 Emulator Joe Moore}{10}
\contentsline {section}{\numberline {3.3}ZIM - The Z80 Machine Simulator}{11}
\contentsline {section}{\numberline {3.4}Podsumowanie istniej\IeC {\k a}cych rozwi\IeC {\k a}za\IeC {\'n}}{11}
\contentsline {chapter}{\numberline {4}Projekt aplikacji}{14}
\contentsline {section}{\numberline {4.1}Podzia\IeC {\l } aplikacji}{14}
\contentsline {section}{\numberline {4.2}XBit}{14}
\contentsline {subsection}{\numberline {4.2.1}Mo\IeC {\.z}liwo\IeC {\'s}ci}{16}
\contentsline {subsection}{\numberline {4.2.2}Za\IeC {\l }o\IeC {\.z}enia projektowe xBit}{16}
\contentsline {subsubsection}{Klasy XBit8 i XBit16}{17}
\contentsline {subsubsection}{Klasa XBitUtils, Arithmetic8bitResult, Arithmetic16bitResult}{18}
\contentsline {section}{\numberline {4.3}z80emu-core}{18}
\contentsline {subsection}{\numberline {4.3.1}Publiczny interfejs modu\IeC {\l }u z80emu-core}{19}
\contentsline {subsection}{\numberline {4.3.2}Elastyczno\IeC {\'s}\IeC {\'c} w \IeC {\l }\IeC {\k a}czeniu z innymi projektami}{21}
\contentsline {section}{\numberline {4.4}z80emu-gui}{22}
\contentsline {chapter}{\numberline {5}Implementacja}{26}
\contentsline {section}{\numberline {5.1}XBit}{26}
\contentsline {subsection}{\numberline {5.1.1}Implementacja klasy Xbit}{27}
\contentsline {subsubsection}{boolean getBit(int index)}{27}
\contentsline {subsubsection}{TSelf setBit(int index, boolean value)}{27}
\contentsline {subsubsection}{int getValueOfBits(int startIndexBit, int stopIndexBit)}{28}
\contentsline {subsubsection}{Inne metody}{29}
\contentsline {subsection}{\numberline {5.1.2}Implementacja klasy Xbit8}{29}
\contentsline {subsection}{\numberline {5.1.3}Implementacja klasy Xbit16}{30}
\contentsline {subsubsection}{public static XBit16 valueOfHighAndLowInBigEndian(XBit8 high, XBit8 low)}{30}
\contentsline {subsubsection}{public static XBit16 valueOfHighAndLowInLittleEndian(XBit8 high, XBit8 low)}{30}
\contentsline {subsubsection}{inne metody}{31}
\contentsline {subsection}{\numberline {5.1.4}Implementacja klasy XbitUtils}{31}
\contentsline {subsubsection}{public static XBit8 incrementBy(XBit8 value, int incrementer)}{31}
\contentsline {subsection}{\numberline {5.1.5}public static XBit8 negativeOf(XBit8 value)}{32}
\contentsline {subsection}{\numberline {5.1.6}public static Arithmetic8bitResult addTwo8bits(XBit8 value1, XBit8 value2)}{33}
\contentsline {subsection}{\numberline {5.1.7}public static Arithmetic8bitResult subTwo8bits(XBit8 value1, XBit8 value2)}{34}
\contentsline {subsection}{\numberline {5.1.8}public static XBit8 not8bit(XBit8 value)}{34}
\contentsline {subsection}{\numberline {5.1.9}public static XBit8 and8bit(XBit8 value1, XBit8 value2)}{34}
\contentsline {subsection}{\numberline {5.1.10}metody wykonuj\IeC {\k a}ce sum\IeC {\k e} bitow\IeC {\k a} i r\IeC {\'o}\IeC {\.z}nice symetryczn\IeC {\k a}}{35}
\contentsline {chapter}{\numberline {6}Testy}{36}
\contentsline {section}{\numberline {6.1}????}{36}
\contentsline {section}{\numberline {6.2}Test-driven development}{36}
\contentsline {chapter}{\numberline {7}Uwagi i wnioski}{39}
